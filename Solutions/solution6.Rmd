---
title: "VI. Bioinformatics in R (solution)"
author: "Center for Health Data Science, University of Copenhagen"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  #pdf_document: default
  html_document: default
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE)
```

&nbsp;

---

In this exercise you will perform differential expression analysis using the `DESeq2` package for R on an RNAseq expression dataset from airway smooth muscle cells. 
You will effectively be performing the same work flow of analysis as the one provided in **presentation 6**, with some variation along the way.   


**About the Dataset**   
Common medicine for treatment of astma are beta2-agonists and glucocorticosteroids, which mainly target the airway smooth muscle.  
The dataset `airway` contains mRNA profiles from bulk RNAseq of smooth muscle cells from four male donors. 
The cell lines were treated with dexamethasone and albuterol, or were left untreated (controls). See original data and summary of intent [here](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE52778).


&nbsp;

---

## PART 1 - Preliminary Analysis

### Install and load packages

For this exercise you will need five R-packages: `tidyverse`, `ggplot2`,  `readxl`, `BiocManager`, `DESeq2`  and `EDASeq`. You should already have these installed!    
Copy the chunk below to your .R or .Rmd file to load packages.    
  **N.B** If you do get an error when trying to load one of the packages below, you can try to install the missing package using `install.packages('my.package')`. 


```{r, warning=FALSE, message=FALSE}
#install.packages("tidyverse")
#install.packages("ggplot2")
#install.packages("readxl")
#install.packages("BiocManager")
#BiocManager::install("DESeq2")
#BiocManager::install("EDASeq")

library(tidyverse)
library(ggplot2)
library(readxl)
library(BiocManager)
library(DESeq2)
library(EDASeq)
library(gridExtra)

```


&nbsp;

---

1. In the exercises folder you will find two files: `airway_counts.xlsx` (RNAseq count data) and `airway_metadata.xlsx` (sample information).   
Read in these two files and name them **_airDat_** and **_airMet_**, respectively.   
  **N.B.** If you are not working from within the exercise folder, you need to remember to either (I) set the full/true path of the files or (II) copy these files to your current working directory.

```{r}
airDat <- read_xlsx("airway_counts.xlsx")
#airDat

airMet <- read_xlsx("airway_metadata.xlsx")
#airMet
```

&nbsp;

---


2. What kind of information do you have in the first four columns of the airDat? How many samples and genes are there in your count data? 

```{r}
# Gene information
airDat %>% 
  dplyr::select(1:4) %>%
  head(., n=3)

# Number of genes
nrow(airDat)

# Number of samples
ncol(airDat)-4
```


3. In your metadata you have four variables, all characters, convert _condition_ and _celltype_ into factors for further analysis. 

```{r}
airMet <- airMet %>% 
  mutate(condition=as.factor(condition), celltype=as.factor(celltype))
```

&nbsp;

**Copy and run the code below**. This line of code will give you a new column in your **airDat** tibble named _nzeros_ (Sum of samples where count less then 3).   
First we temporarily de-select the columns with gene information, then we count <=3 across samples.

```{r}
airDat <- airDat %>% 
  mutate(nzeros = rowSums(dplyr::select(., -Ensgene, -GeneSymbol, -GC, -Length)<=3))
```

&nbsp;

4. We do not want any genes where less than half of the samples have a count above 3. Filter out the genes for which this is the case, and remove the column _nzeros_ from your tibble after filtering. 
Check how many genes you are left with.
   
```{r}
airDatFilt <- airDat %>%
  filter(nzeros <= 4) %>%
  dplyr::select(-nzeros)

dim(airDatFilt)
```

5. To get an idea of sample library sizes make a boxplot of gene counts, one for each sample.
You will need to `gather()` the gene counts across samples into one column and the sample IDs into another column. Assign this output to a new variable named `airPlot`.   
  **HINT 1:** First remove the columns with information on genes (there are four) and next use this: `gather(key = ID, value=geneCount)` to gather the counts into one column.   
  **HINT 2:** Use `geom_boxplot()` to make a boxplot with ggplot2. Extra: To tilt your x-axis labels 90 degrees, add `theme(axis.text.x = element_text(angle = 90))` to your ggplot code.   

```{r}
airPlot <- airDatFilt %>% 
  dplyr::select(-Ensgene, -GeneSymbol, -GC, -Length) %>%
  gather(key = ID, value=geneCount)


airPlot
```

```{r}
p1 <- ggplot(airPlot, aes(ID, geneCount)) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90)) 

p1
```

6. You will see that boxplots are squeezed due to difference in count range between genes. Which type of data transformation could you use to overcome this problem?   
Remake the boxplot with transformed counts.   
  **HINT** remember to add 1.0 pseudo count to all counts before transformation to handle counts which are 0.

```{r}
p2 <- ggplot(airPlot, aes(ID, log2(geneCount+1))) + geom_boxplot() + theme(axis.text.x = element_text(angle = 90)) 

p2
```


&nbsp;


#### Adjusting for GC content and gene length:

It is well-established that gene length and GC-content will affect the number of reads obtained. It is therefore standard practice to check for such biases and correct accordingly. You already have information on length and GC content in the **airDatFilt** tibble.

The `EDAseq` package can help you correct for gene length and GC content.
`EDAseq` provides a `biasPlot` showing you if GC content and gene length are a problem. To use this function your data must be in a format that `biasPlot` accepts, e.g. an `EDAseq` object.   

7. Copy the code from both chunks below and run it. Have a look at the object you created, named _EDAobj_, and importantly, look at the plots created, does there appear to be a GC and/or gene length bias in your data?
  **HINT 1:** An unbias dataset should not show any trend in GC content or gene length across gene counts.   

```{r}
# Converts tibble to matrix of expression counts and removes gene information:
airDatM <- airDatFilt %>% 
  dplyr::select(-Ensgene, -GeneSymbol, -GC, -Length) %>% 
  as.matrix() %>% 
  unname()

# Make EDASeq object 
EDAobj <- newSeqExpressionSet(airDatM, 
                              phenoData=AnnotatedDataFrame(data.frame(condition=airMet$condition, 
                                                                      celltype=airMet$celltype)),
                              featureData=AnnotatedDataFrame(data.frame(GC=airDatFilt$GC, 
                                                                        Length=airDatFilt$Length)))
```

```{r}
# Bias plots
par(mfrow=c(1,2))
biasPlot(EDAobj, "GC", log=TRUE, ylim=c(0,10))
biasPlot(EDAobj, "Length", log=TRUE, ylim=c(0,10))
```

&nbsp;

If you observe a bias in your data, you can correct for this with the function `withinLaneNormalization` from `EDASeq`. You can have a look at the [EDASeq documentation](https://www.bioconductor.org/packages/devel/bioc/vignettes/EDASeq/inst/doc/EDASeq.html#retrieving-gene-length-and-gc-content) under point 5 for more info on this function.   

8. Copy and run the code in below to normalize your _EDAobj_ object for GC content and gene length.
Remake the `biasPlot` from above with the _EDAobjNorm_ object. Are the biases removed?


```{r}
EDAobjNorm <- withinLaneNormalization(EDAobj, "GC", which="full", offset=TRUE) %>% 
  withinLaneNormalization(., "Length", which="full", offset=TRUE)

par(mfrow=c(1,2))
biasPlot(EDAobjNorm, "GC", log=TRUE, ylim=c(0,10))
biasPlot(EDAobjNorm, "Length", log=TRUE, ylim=c(0,10))
```




&nbsp;
---

## PART 2 - Differential Expression Analysis with DESeq2

Now we we begin our differential expression analysis in `DESeq2`. First, we use the function `DESeqDataSetFromMatrix` to make a `DESeq2 object` (just as shown in the presentation). 

9. Fill in the DESeq2 object below. We want our design matrix to include _celltype_ and _condition_ from the metadata, (**airMet**). Fill in the _countData_, _colData_ and _design_ (rowData is optional).  
  **HINT** Your countData must only contain counts, no gene IDs etc., so you should filter/slice these these columns out before addition the counts it to the object.

```{r}

exprObj <- DESeqDataSetFromMatrix(countData = airDatFilt[,-c(1:4)],
                              rowData = airDatFilt[,1:4],
                              colData = airMet,
                              design=~celltype+condition)
exprObj
```
10.
```{r}
exprObj <- DESeqDataSetFromMatrix(countData = counts(EDAobjNorm),
                             colData = pData(EDAobjNorm),
                             design = ~celltype+condition)

normFactors <- exp(-1 * offst(EDAobjNorm))
normFactors <- normFactors / exp(rowMeans(log(normFactors)))
normalizationFactors(exprObj) <- normFactors

```



&nbsp;

In question 5., we made a ggplot2 boxplots to see the difference in library sizes and variances of samples. Based on this plot it seems like variance stabilizing transformation might improve our dataset for DEA analysis. Copy and run the code below to perform vst transformation.   
  **Extra (optional)**: Make a boxplot with the vst counts.


```{r}
exprObjvst <- vst(exprObj,blind=FALSE)
```

```{r}
boxplot(assay(exprObjvst), xlab="", ylab="Log2 counts per million reads mapped ",las=2)
```

We would like to inspect if the vst transformation has improved the clustering of our samples by the group. For this, previously we have used Principal Component Analysis (PCA), however, there are many different methods to accomplish the task. 

Here we apply the Multidimensional Scaling method (also known as principal coordinates analysis) to perform dimensionality reduction analysis using both the 'raw' and vst-transformed data. We extract counts from the DESeq2 objects using the function `assay()`.


11. Copy and run the two chunks of code below.   
In the second chunk we are using three different functions: `t()`, `dist()` and `cmdscale()`. Use **?** to figure out what each of them do! What inputs do they take? and what are the default values?

```{r}
# un-transformed counts
unTrf <- assay(exprObj)
head(unTrf, n=3)

# vst transformed counts
vstTrf <- assay(exprObjvst)
head(vstTrf, n=3)
```

```{r}
# un-transformed counts
unTrf <- unTrf %>% t() %>% 
    dist() %>% cmdscale(., eig=TRUE, k=2)

unTrf <- tibble(PCo1=unTrf$points[,1],PCo2=unTrf$points[,2])

# vst transformed counts

vstTrf <- vstTrf %>% t() %>% 
    dist() %>% cmdscale(., eig=TRUE, k=2)

vstTrf <- tibble(PCo1=vstTrf$points[,1],PCo2=vstTrf$points[,2])

```


&nbsp;

You now have two datasets containing the first two principal coordinates (PCa1 & PCo2) for both 'raw' (un-transformed) counts, _unTrf_, and vst-transformed counts, _vstTrf_. 

12. Make a PCaA plot for each set using ggplot2. Color the samples by condition and label them by _celltype_ (**airMet** has this information).   
  **HINT** A PCoA plot is just a `geom_point()` plot with x=PCo1 and y=PCo2. Would you say that the transformation improved the partitioning of control and treated samples?


```{r}
# PCA Plot
# Takes as arguments:
# countDat = a dataframe of expression counts
# groupVar = a factor vector of groups (conditions) to color points by (may be the same or different as labelVar)
# labelVar = a vector of IDs for labeling (may be the same or different as groupVar)
# colVar = a vector of colors (one color for each group)
# -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


pcaPlot <- function(countDat, groupVar, labelVar, colVar) {
  
  # Make basic plot
  pcap <- ggplot(data=countDat) + geom_point(aes(x=PCo1,y=PCo2,color= groupVar), size=2) + 
    geom_text(aes(x=PCo1,y=PCo2, label=labelVar)) +
    
    # Improve look of plot:
    theme_minimal() + theme(panel.grid.minor = element_blank()) + 
    scale_color_manual(values = colVar) +
    theme(legend.title=element_blank(), legend.text = element_text(size = 12, face="bold"), legend.position = "top", axis.title=element_text(size=12,face="bold")) +
    guides(colour = guide_legend(override.aes = list(size=6)))
  return(pcap)
}

```


```{r}
# Make plot
p3 <- pcaPlot(unTrf, airMet$condition, airMet$celltype, c("#7692FF", "#F26419"))
p4 <- pcaPlot(vstTrf, airMet$condition, airMet$celltype, c("#7692FF", "#F26419"))

grid.arrange(p3, p4, ncol=2)

```

&nbsp;

Next, we use `DEseq()` to estimate dispersion, gene-wise and mean-dispersion, fitting model(s). Copy the code below and run it.

```{r}
# Fitting gene-wise glm models:
exprObj <- DESeq(exprObj)
```

&nbsp;

We now have our model(s) ready and we want to contrast our condition groups, e.g. treated vs control.   

13. Use the `DESeq2` function `results()` to do the post hoc test (just like we did in the presentation). Figure out what arguments it takes. As a minimum you will have to specify a DESeq2 model object (denoted by '.' below) and a contrast of interest. When you have run the function, have a look at the output.   


```{r, eval=FALSE}
resTC <- results(. , contrast = c(), independentFiltering = FALSE)
```

```{r}
# Test for DE genes between lactating mice and control mice adjusted for cell type:
# Lactating vs Control mice
resTC <- results(exprObj, contrast = c("condition", "treated", "control"), independentFiltering = FALSE)
```


14. Use the function `summary()` to see the number of identified differentially expressed gene. Use the `plotMA()` function to visualize these.

```{r}
# Summary and plot of DE analysis results:
summary(resTC)
DESeq2::plotMA(resTC)
```


&nbsp;

15. Convert your results from `DESeq2` to a tibble and do the following:   
    (a) Add two new columns to it (using `mutate`): _dir_ indicating directionality of the logFC. The column _dir_ can be made using the following syntax: `dir=factor(ifelse(log2FoldChange >= 1.0, "Up", "Down"), levels=c("Up", "Down"))` and one named _geneSymbols_ with gene symbols from _airDatFilt_.
    (b) Filter your results to only include genes with log2FoldChange of more than 1 or less than -1 and a _padj_ (adjusted p-value) of less than 0.05. 
    (c) Arrange by _padj_ (ascending) and the **absolute** _log2FoldChange_ (descending). **HINT:** use the function `abs()` to get the absolute log2FoldChange before arranging.
    (d) Extract the top 50 most significant DE genes based on _log2FoldChange_ and _padj_.
    

```{r}
resTC <- resTC %>% 
  as_tibble() %>% 
  mutate(dir=factor(ifelse(log2FoldChange >= 1.0, "Up", "Down"), levels=c("Up", "Down")), 
         geneSymbol=airDatFilt$GeneSymbol) %>%
  filter((log2FoldChange > 1.0 | log2FoldChange < -1.0) & padj < 0.05) %>%
  arrange(padj, desc(abs(log2FoldChange))) %>%
  top_n(50)
```

&nbsp;

16. Make a lollipop plot (https://www.r-graph-gallery.com/lollipop-plot.html) of the top 50 most significant DE genes:
    (a) You will need two ggplot geoms for this: `geom_segment()` and `geom_point()`.
    (b) The size of the point should reflect the log2FoldChange and the shade of the point should reflect the significance (e.g. the padj). *N.B* you may have to scale one or both of these to get a nicer plot.
    (c) Change the color scheme to one you would like, try `scale_colour_gradient2()`.
    (d) Play around with the look/theme of the plot, remove legends you dont need, grid lines etc.
    (e) Based on your plot, which genes seem to be most effected by treatment with dexamethasone and albuterol?


```{r}

resTC <- resTC %>% 
  mutate(geneSymbol = factor(geneSymbol, levels = unique(geneSymbol)), 
         absLog2FC=abs(log2FoldChange))

resTC <- resTC %>% 
  mutate(geneSymbol = factor(geneSymbol, levels = unique(geneSymbol)), 
         absLog2FC=abs(log2FoldChange))

ggplot(resTC, aes(x=geneSymbol, y=log2FoldChange)) +
  geom_segment(aes(x = geneSymbol, xend = geneSymbol, y = 0, yend = log2FoldChange, color=abs(log2(padj))), size = 1) + geom_point(aes(color=abs(log2(padj)), size=absLog2FC)) + 
  theme_bw() +
  scale_colour_gradient2(high = "#FF9B71", mid="#003049" ,low ="#003049", na.value = NA, midpoint = 12, breaks = c(5, 60, 120), labels = c("3.4-02", "2.2e-04", "4.1e-37")) +
  theme(panel.grid.major.x = element_blank(), axis.title.x = element_blank(), axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size=7)) + 
  guides(size="none") + labs(color='Adjusted p-value') 


```
