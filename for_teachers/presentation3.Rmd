---
title: "VI. Bioinformatics in R (presentation)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  #pdf_document: default
  html_document: default
---

```{r ch0, setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


## Importing libraries and data

The examples below use the *downloads* dataset, which also was used for the presentation **Working with data in R**. This dataset is available as an Excel file, which we will import using the **readxl** package. Furthermore, **ggplot2** is part of the **tidyverse** package, so we also load that:

```{r ch1}
library(readxl)
library(tidyverse)
```


We read the *downloads* dataset from the Excel file, and assign it to a `tibble` named *downloads*. Doing this we only keep the observations, where the *size* variable is strictly larger than zero: 

```{r ch2}
#Get a path to FromExceltoR folder
my_path<-gsub("/for_teachers.*","",getwd())
#Get a path to data folder
path <- paste0(my_path,"/Presentations/data/")

downloads <- 
  read_excel(paste0(path,"downloads.xlsx")) %>% 
  filter(size > 0)
downloads
```


## ggplot2: The basic concepts

A ggplot-object is a syntaxical description of a plot. You may think of it as a recipe in a cookbook. To *cook the dish*, that is to make the plot, you *print* the ggplot-object. By default the results of all R commands executed in the *Console* are automatically printed. Thus, as a result the plot will be generated on the computer screen. Alternatively, you can use the `ggsave()` command to print the syntaxical plot description into a graphics file to be used in scientific papers and/or presentations.

To write down a recipe for a dish you usually start with a blank sheet of paper. We do the same for our graphical recipes. The equivalent of a blank sheet of paper is generated by the command `ggplot()`. The ingredients for our plot is a dataset, which should be available as a `data.frame` or as a `tibble`. We should also specify what the ingredients should be used for. In the language of ggplot2 this is done by specifying *aesthetics* via the `aes()`command.  

Suppose we want to use data from the tibble *downloads*, and plot *machineName* on the x-axis and the sum of the **size of the all downloads** on the y-axis. We use the techniques presented in **Working with data in R** to generate a `tibble` called **dl_sizes** containing the sum of all downloads sizes from the 6 different machines.

We do this via the following steps:

1. Using `group_by()` we group the dataset by *machineName*.

2. Using `summarize()` we sum the size of the downloads within each machine.

Then we write a ggplot function.


```{r ch3, fig.width=6, fig.asp=0.6}
dl_sizes <- downloads %>% 
  group_by(machineName) %>% 
  summarise(size = sum(size))

ggplot(dl_sizes,aes(x=machineName,y=size))
```

The reason that we don't see any points, lines or the like is, of course, that we did not yet ask for such thins to be made! Geometrical objects like points and lines are called **geoms** in ggplot2. But although we did not yet add any geoms to our plot, we see that the plot already recognized the range of the variables specified in the aesthetics.


## A simple bar chart

To make a bar chart we add `geom_col()` to the syntaxical description. In the code below we have also rescaled the size of the downloaded files to be measured in mega bytes instead of bytes. This is done by downscaling the *size* variables by a factor 1,000,000.

```{r ch4, fig.width=6, fig.asp=0.6}
ggplot(dl_sizes, aes(x = machineName, y = size/10^6)) + 
  geom_col()
```

We remark, that *machineName* used on the x-axis is a categorical variable. In R the levels of a categorical variable by default are ordered alphabetically. Which is also what we see on this plot.



## A bar chart with ordered bars

Suppose we like the machines in the bar chart to be ordered according to increasing download size. One way to achieve this is to recode the variable *machineName* as a `factor` (in R categorical variables are called factors) with levels ordered according to increasing download size. Thereafter we order *dl_sizes* `tibble` according to the total download size using `tidyverse` function `arrange`.

```{r ch5}
dl_sizes <- dl_sizes %>% 
  arrange(size)
dl_sizes
```

Now we recode the *machineName* variable, so that the levels appear in increasing size according to total download size:

```{r ch5b}

dl_sizes$machineName

dl_sizes <- dl_sizes %>% 
  mutate(machineName = factor(machineName, levels = dl_sizes$machineName))

dl_sizes$machineName
```

Finally, we can make the plot using the same `ggplot()` code as above. Thus, the same `ggplot()` code with a changed dataset (remember, that we made a new ordering of the levels of the variable *machineName*) will give a new plot:

```{r ch6, fig.width=6, fig.asp=0.6}
ggplot(dl_sizes, aes(x = machineName, y = size/10^6)) + 
  geom_col()
```

---

## Flipping the bar chart

In the next R chunk we will for the first time try to save the syntaxical description of a plot in an R variable. The benefit of doing this is that the syntaxical description easily may be reused, possibly with variations. In the metaphor of a *recipe in a cookbook* think of giving a piece of paper with the recipe of your favorite dish to a friend. Let's try out this idea, and write down the recipe for the bar chart in an R variable called *p*:

```{r ch7}
p <- ggplot(dl_sizes, aes(x = machineName, y = size/10^6)) + 
  geom_col()
```

This does not yet produce a new plot. But a variable called *p* has appeared in the *global environment*. Now imagine you give the recipe to your friend. Your friend is happy and thank you for the wonderful recipe, but decide to cook the bar chart with horizontal bars instead of vertical bars. This is done by flipping the coordinate axes...

```{r ch8, fig.width=6, fig.asp=0.6}
p + coord_flip()
```

---

## Exploring monthly download info

Next, we would like to look at the total downloads size per month for each of the machines. For that, we create a new `tibble` called *dl_sizes_month*. 

```{r ch9}
dl_sizes_month <- downloads %>% 
  group_by(machineName, month) %>% 
  summarise(size = sum(size)) %>% 
  arrange(size) %>% 
  mutate(machineName = factor(machineName, levels = dl_sizes$machineName))
```

We can extend the graphics further by adding new *aesthetics* and/or *geoms*. Looking at the help page `?geom_col` we see that the *fill*-aesthetic will be interpreted by `geom_col()`. To see the effect of this aesthetic on that geom we simply try it out.

```{r ch10, fig.width=6, fig.asp=0.6}

p <- ggplot(dl_sizes_month, aes(x = machineName, y = size/10^6, fill = month)) 
p +  geom_col()

```

We see that the bars have the same height as before, and still visualize the total download size. But now the total download size also has been subdivided according to month. This is visualized by colors, and a legend for the interpretation of the colors is automatically added in the right panel of the plot.


---

### Some other bar chart options

Above we realized that setting the *fill*-aesthetic results in a subdivision of the contributions to the bars. How this is displayed may be changed by setting the *position*-option in the `geom_col()` call or by changing the grid for the ggplot. Let's try it out!

```{r ch11, fig.width=3.8, fig.asp=0.718, fig.align = "default", fig.show = "hold"}

p + geom_col(position = "dodge") ## Left/first plot
p + geom_col(position = "fill") ## Right/second plot

```


```{r ch12, fig.width=3.8, fig.asp=0.718, fig.align = "default", fig.show = "hold"}

p +  geom_col() + facet_grid(vars(month))
p +  geom_col() + facet_wrap(vars(month))

```

---

##  A box plot - grouping by machine and month

Let’s also try to make a boxplot of mean monthly downloads for each of the machines. This time we will use the original *downloads* dataset instead of the summary `tibble`.

And perhaps the boxplot is more informative on the log-scale? 

To change the y-axis to be logarithmic we add `scale_y_log10()`. Please note, that for visualizations we often prefer the base-10 logarithm (whereas statisticians often use the natural logarithm for modeling). However, for some applications the natural or the base-2 logarithm might be the preferable choice.


```{r ch13, fig.width=6, fig.asp=0.6}
p <- ggplot(downloads, aes(x = machineName, y = size, fill=machineName)) + 
  geom_boxplot() + 
  scale_y_log10()
p
```


Let’s try out our newly acquired plotting skills by including *groups* and *fill* *aesthetics* via the `aes()` command.


```{r ch14}

p1 <- ggplot(downloads, aes(x = machineName, y = size, groups = month, fill=month)) + 
  geom_boxplot()
p1 <- p1 + scale_y_log10() 
p1

```


Now let's make a violin plot, which is a boxplot that shows the distribution of points. We will log-scale it again, and this time we will change the colors as well.

We can add the point to the violin outline and specify custom colors manually, like this:
```{r ch15, fig.width=6, fig.asp=0.6}
p <- ggplot(downloads, aes(x = machineName, y = size, fill=machineName)) + 
  geom_violin(trim = TRUE) + scale_y_log10() 

p

p2 <- p + geom_jitter(size = 0.1, alpha = 0.05, width = 0.4) + 
  theme_minimal() +
  scale_fill_manual(values=c("#2A2D43", "#91A6FF", "#C7EDE4", "#AFA060", "#AD8350"))
p2
```


---
## Daily summary statistics

Next we want to visualize the number and the total size of the downloads done each date for each of the 6 machines. For later usage we also compute the cumulated number of downloads within each of the 6 machines over the dates. As before we do this via the following steps:

1. Using `group_by()` we group the dataset by both *machineName* and *date*.

2. Using `summarize()` we count the number and the total size of the downloads for within each machine and date.

3. Using `mutate()` we cumulate the number of downloads over the dates within the machines. We remark that `cumsum` makes the cumulative sum over the innermost grouping variable, which is *date*.

```{r ch16}
daily_downloads <- downloads %>%
    group_by(machineName, date) %>% 
    summarize(dl_count = n(), size_mb = sum(size)/10^6) %>%
    mutate(total_dl_count = cumsum(dl_count))
daily_downloads
```


## A simple scatter plot

To make a scatterplot we use `geom_point()`. In order to make it more easy to try out different layout features on the same plot, we save the ggplot-description in the variable *p*. Please note that this, of course, will overwrite the previous content of *p*. Thus, after executing the following R check *p* will contain the description of a scatterplot. 
We will also *log* transform y-axis.

```{r ch17, fig.width=6, fig.asp=0.6}
p <- ggplot(daily_downloads, aes(x = date, y = dl_count)) +
  geom_point() 
p <- p + scale_y_log10()
p
```



## Points colored by machine

Remember, that *p* presently encodes a scatterplot, which is made using `geom_point()`. To color the points according to *machineName* we simply add this as an aesthetic.

```{r ch18, fig.width=6, fig.asp=0.6}
p + aes(color = machineName)
```


## Points shaped by machine

Alternatively, we can visualize the 6 different machines by different plotting symbols. This is done by adding a *shape* aesthetic instead.

```{r ch19, fig.width=6, fig.asp=0.6}
p + aes(shape = machineName)
```

Please note that *ggplot2* only contains 6 different plotting symbols. If you using the *shape* aesthetic on a categorical variable with more than 6 levels, then you get the following error message:

```{r ch20, eval=FALSE}
>p + aes(shape = factor(size_mb))
Warning messages:
1: The shape palette can deal with a maximum of 6 discrete values because more than 6 becomes difficult to
discriminate; you have 337. Consider specifying shapes manually if you must have them. 
2: Removed 331 rows containing missing values (geom_point). 
```


## Bobble plot

The *bobble plot* is an extension of the classical *scatterplot*. Recall, that a scatterplot displays two numerical variables via the x-axis and the y-axis. The idea of the bobble plot is to visualize a third numerical variable by letting it encode the size of the points. The best human perception of size is achieved when the area (and not the diameter, say) of the points is taken to be proportional to this third numerical variable. This is exactly what is achieved by the *size* aesthetic:

```{r ch21, fig.width=6, fig.asp=0.6}
p + aes(size = size_mb)
```

Please note, that *"size"* appearing on the left hand side is the name of the aesthetic known by **ggplot2**, whereas *"size_mb"* on the right hand side is the name of the variable inside the tibble *downloads*.



## Points colored by download size

The ideas exemplified above may be combined. E.g.\ to make a stronger visualization of the daily total download size we may choose to make a combined usage of the *size* and the *color* aesthetic.

```{r ch22, fig.width=6, fig.asp=0.6}
p + aes(size = size_mb, color = size_mb > 2)
p3 <- p + aes(size = size_mb, color = size_mb > 2)

```

From the inserted legend in the right panel of the plot it should be clear how the colors are to be interpreted.



## Cumulated total download size over the dates within machines

The geom called `geom_line()` is used to insert lines. In the code below you see a first attempt to write R code that visualizes the cumulated total download size over the dates.

```{r ch23, fig.width=6, fig.asp=0.6}
ggplot(daily_downloads, aes(x = date, y = total_dl_count)) + 
  geom_line() 
```

However, in the code above we forgot to make the lines *within the machines*. This may be achieved by adding a *group* aesthetic as shown in the following code.

```{r ch24, fig.width=6, fig.asp=0.6}

p4 <- ggplot(daily_downloads, aes(x = date, y = total_dl_count)) + 
  geom_line(aes(group = machineName, colour = machineName)) 
p4 


```




## Arrange multiple ggplots on the same page

In R there is a whole infrastructure of extension packages built around ggplot, that facilitate different types of plot modifications, arrangements, and animation. 

R package **ggpubr** is one of them and it helps to produce publication-ready plots using ggplot2.

```{r ch25, fig.width=8, fig.asp=0.6}

# install.packages("ggpubr")
library(ggpubr)

figure <- ggarrange(p1, p2, p3, p4,
                    ncol = 2, nrow = 2)
figure

```


You can modify saved ggplot objects, arrange, align and label plots individual plots.

```{r ch26, fig.width=8, fig.asp=0.6}

figure <- ggarrange(p1 + theme_bw(),
                    p3 + theme_bw() + 
                      scale_color_manual(values=c("#2A2D43", "#91A6FF", "#AD8350")),
                    p4 + theme_bw()+
                      scale_color_manual(values=c("#2A2D43", "#91A6FF", "#C7EDE4", "#AFA060", "#AD8350")), 
                    p2 + theme_bw(), 
                    align = "hv",
                    labels = c ("A", "B", "C", "D"),
                    ncol = 2, nrow = 2)
figure
```



```{r ch27}

## Save Tibble and Save Plot:

#write_xlsx(daily_downloads, "daily_downloads.xlsx")

#ggsave(filename = "vionlinPlot.pdf", plot = p2, height = 5, width = 10)

#pdf("vionlinPlot2.pdf", height = 5, width = 10)
#p2
#dev.off()
```



## Conclusion

1. The **ggplot2** package is a powerful and versatile tool for making plots.

1. We think, that the generated plots are beautiful.

1. As far as we know some plots, e.g. using *faceting* (see the exercises), in practice are only producible in **ggplot2**.

1. Learning the syntax needed for making specific plots is a challenge. The best way (the only way!?) to learn is to practice. You may start by solving the exercise sheet. After you have gotten used to the basic ideas you can find a lot of help on the internet. We remark, that there have been several updates of the **ggplot2** package over the recent years. And some of the old entries that might pop up when you google a ggplot2-issue might be outdated.

1. Not all things can be made in **ggplot2**! For a geometrical object to be available it need to have a syntaxical description, and it needs to be implemented. Other things require computer-hacks to be made (e.g. using different orderings of categorical variables in faceted plots).
